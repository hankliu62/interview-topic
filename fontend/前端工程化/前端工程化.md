<!--
 * @owner: hank.liu
 * @team: 卡鲁秋
-->

# 前端工程化 面试知识点总结

本部分主要是笔者在复习 前端工程化 相关知识和一些相关面试题时所做的笔记，主要是个人复习使用，如果出现错误，希望并感谢大家指出，如总结答案与标准有出入，请轻喷，谢谢🙏

## 前端安全、中间人攻击

### 1）XSS：跨站脚本攻击

就是攻击者想尽一切办法将可以执行的代码注入到网页中。

#### 存储型(server端)

- 场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

- 攻击步骤：
  - 1. 攻击者将恶意代码提交到目标网站的数据库中
  - 2. 用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器
  - 3. 用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行
  - 4. 恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作

#### 反射型(Server端)

与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在URL上

- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。

- 攻击步骤：
  - 1. 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  - 3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### Dom 型(浏览器端)

DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
- 攻击步骤：
  - 1. 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 2. 用户打开带有恶意代码的 URL。
  - 3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
  - 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 预防方案

防止攻击者提交恶意代码，防止浏览器执行恶意代码。

- 1. 对数据进行严格的输出编码：如HTML元素的编码，JS编码，CSS编码，URL编码等等
  - 避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML

- 2. CSP HTTP Header，即 Content-Security-Policy、X-XSS-Protection
  - 增加攻击难度，配置CSP(本质是建立白名单，由浏览器进行拦截)
  - `Content-Security-Policy: default-src 'self'` - 所有内容均来自站点的同一个源（不包括其子域名）
  - `Content-Security-Policy: default-src 'self' *.trusted.com` - 允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)
  - `Content-Security-Policy: default-src https://yideng.com` - 该服务器仅允许通过HTTPS方式并仅从yideng.com域名来访问文档

- 3. 输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断

- 4. 开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。

- 5. 验证码

### CSRF：跨站请求伪造

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

#### 攻击流程举例

1. 受害者登录 a.com，并保留了登录凭证（Cookie）
2. 攻击者引诱受害者访问了b.com
3. b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie
4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
5. a.com以受害者的名义执行了act=xx
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作

#### 攻击类型

1. GET型：如在页面的某个 img 中发起一个 get 请求
2. POST型：通过自动提交表单到恶意网站
3. 链接型：需要诱导用户点击链接

#### 预防方案

CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。

- 1. 同源检测：通过Header中的Origin Header 、Referer Header 确定，但不同浏览器可能会有不一样的实现，不能完全保证

- 2. CSRF Token 校验：将CSRF Token输出到页面中（通常保存在Session中），页面提交的请求携带这个Token，服务器验证Token是否正确

- 3. 双重cookie验证：
  - 流程：
    - 步骤1：在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）
    - 步骤2：在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）
    - 步骤3：后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。
  - 优点：
    - 无需使用Session，适用面更广，易于实施。
    - Token储存于客户端中，不会给服务器带来压力。
    - 相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。
  - 缺点：
    - Cookie中增加了额外的字段。
    - 如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。
    - 难以做到子域名的隔离。
    - 为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。
- 4. Samesite Cookie属性：Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，Strict 为任何情况下都不可以作为第三方 Cookie ，Lax 为可以作为第三方 Cookie , 但必须是Get请求

### 3）iframe 安全

#### 说明

- 1. 嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题
- 2. 点击劫持
  - 攻击者将目标网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，诱导用户点击。
- 3. 禁止自己的 iframe 中的链接外部网站的JS

#### 预防方案

- 1. 为 iframe 设置 sandbox 属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则
- 2. 服务端设置 X-Frame-Options Header头，拒绝页面被嵌套，X-Frame-Options 是HTTP 响应头中用来告诉浏览器一个页面是否可以嵌入 \<iframe> 中
  - eg.X-Frame-Options: SAMEORIGIN
  - SAMEORIGIN: iframe 页面的地址只能为同源域名下的页面
  - ALLOW-FROM: 可以嵌套在指定来源的 iframe 里
  - DENY: 当前页面不能被嵌套在 iframe 里
- 3. 设置 CSP 即 Content-Security-Policy 请求头
- 4. 减少对 iframe 的使用

### 4）错误的内容推断

#### 说明

文件上传类型校验失败后，导致恶意的JS文件上传后，浏览器 Content-Type Header 的默认解析为可执行的 JS 文件

#### 预防方案

设置 X-Content-Type-Options 头

### 5）第三方依赖包

减少对第三方依赖包的使用，如之前 npm 的包如：event-stream 被爆出恶意攻击数字货币；

### 6）HTTPS

#### 描述

黑客可以利用SSL Stripping这种攻击手段，强制让HTTPS降级回HTTP，从而继续进行中间人攻击。

#### 预防方案
解决这个安全问题的办法是使用HSTS（HTTP Strict Transport Security），它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信：

``` header
Strict-Transport-Security: max-age=<seconds>; includeSubDomains; preload
```

这里的“强制性”表现为浏览器无论在何种情况下都直接向服务器端发起HTTPS请求，而不再像以往那样从HTTP跳转到HTTPS。另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户选择是否继续进行不安全的通信。

### 7）本地存储数据

避免重要的用户信息存在浏览器缓存中

### 8）静态资源完整性校验

#### 描述

使用 内容分发网络 (CDNs) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件），因此可能潜在地攻击所有从该 CDN 获取文件的站点。

#### 预防方案

将使用 base64 编码过后的文件哈希值写入你所引用的 `<script>` 或 标签的 integrity 属性值中即可启用子资源完整性能。

### 9）网络劫持

#### 描述

- DNS劫持（涉嫌违法）：修改运行商的 DNS 记录，重定向到其他网站。DNS 劫持是违法的行为，目前 DNS 劫持已被监管，现在很少见 DNS 劫持
- HTTP劫持：前提有 HTTP 请求。因 HTTP 是明文传输，运营商便可借机修改 HTTP 响应内容（如加广告）。

#### 预防方案

全站 HTTPS

### 10）中间人攻击

中间人攻击（Man-in-the-middle attack, MITM），指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者窃听、篡改甚至完全控制。没有进行严格的证书校验是中间人攻击着手点。目前大多数加密协议都提供了一些特殊认证方法以阻止中间人攻击。如 SSL （安全套接字层）协议可以验证参与通讯的用户的证书是否有权威、受信任的数字证书认证机构颁发，并且能执行双向身份认证。攻击场景如用户在一个未加密的 WiFi下访问网站。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。

#### 场景

1. 在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络
2. Fiddler / Charles （花瓶）代理工具
3. 12306 之前的自己证书

#### 过程

1. 客户端发送请求到服务端，请求被中间人截获
2. 服务器向客户端发送公钥
3. 中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端
4. 客户端收到伪造的公钥后，生成加密hash值发给服务器
5. 中间人获得加密hash值，用自己的私钥解密获得真秘钥,同时生成假的加密hash值，发给服务器
6. 服务器用私钥解密获得假密钥,然后加密数据传输给客户端

#### 使用抓包工具fiddle来进行举例说明

1. 首先通过一些途径在客户端安装证书
2. 然后客户端发送连接请求，fiddle在中间截取请求，并返回自己伪造的证书
3. 客户端已经安装了攻击者的根证书，所以验证通过
4. 客户端就会正常和fiddle进行通信，把fiddle当作正确的服务器
5. 同时fiddle会跟原有的服务器进行通信，获取数据以及加密的密钥，去解密密钥

#### 常见攻击方式

1. 嗅探：嗅探是一种用来捕获流进和流出的网络数据包的技术，就好像是监听电话一样。比如：抓包工具
2. 数据包注入：在这种，攻击者会将恶意数据包注入到常规数据中的，因为这些恶意数据包是在正常的数据包里面的，用户和系统都很难发现这个内容。
3. 会话劫持：当我们进行一个网站的登录的时候到退出登录这个时候，会产生一个会话，这个会话是攻击者用来攻击的首要目标，因为这个会话，包含了用户大量的数据和私密信息。
4. SSL剥离：HTTPS是通过SSL/TLS进行加密过的，在SSL剥离攻击中，会使SSL/TLS连接断开，让受保护的HTTPS，变成不受保护的HTTP（这对于网站非常致命）
5. DNS欺骗：攻击者往往通过入侵到DNS服务器，或者篡改用户本地hosts文件，然后去劫持用户发送的请求，然后转发到攻击者想要转发到的服务器
6. ARP欺骗： ARP(address resolution protocol)地址解析协议，攻击者利用APR的漏洞，用当前局域网之间的一台服务器，来冒充客户端想要请求的服务端，向客户端发送自己的MAC地址，客户端无从得到真正的主机的MAC地址，所以，他会把这个地址当作真正的主机来进行通信，将MAC存入ARP缓存表。
7. 代理服务器

#### 预防方案

1. 用可信的第三方CA厂商
2. 不下载未知来源的证书，不要去下载一些不安全的文件
3. 确认你访问的URL是HTTPS的，确保网站使用了SSL，确保禁用一些不安全的SSL，只开启：TLS1.1，TLS1.2
4. 不要使用公用网络发送一些敏感的信息
5. 不要去点击一些不安全的连接或者恶意链接或邮件信息

### 11）sql 注入

#### 描述

就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗数据库服务器执行恶意的SQL命令,从而达到和服务器
进行直接的交互

#### 预防方案

1. 后台进行输入验证，对敏感字符过滤。
2. 使用参数化查询，能避免拼接SQL，就不要拼接SQL语句。

### 12）前端数据安全

#### 描述

反爬虫。如猫眼电影、天眼查等等，以数据内容为核心资产的企业

#### 预防方案

1. font-face拼接方式：猫眼电影、天眼查
2. background 拼接：美团
3. 伪元素隐藏：汽车之家
4. 元素定位覆盖式：去哪儿
5. iframe 异步加载：网易云音乐

### 13）其他建议

1. 定期请第三方机构做安全性测试，漏洞扫描
2. 使用第三方开源库做上线前的安全测试，可以考虑融合到CI中
3. code review 保证代码质量
4. 默认项目中设置对应的 Header 请求头，如 X-XSS-Protection、 X-Content-Type-Options 、X-Frame-Options Header、Content-Security-Policy 等等
5. 对第三方包和库做检测：NSP(Node Security Platform)，Snyk


## 什么是单页面应用(SPA)？

* 单页面应用(SPA)是指用户在浏览器加载单一的HTML页面，后续请求都无需再离开此页
* 目标：旨在用为用户提供了更接近本地移动APP或桌面应用程序的体验。

* 流程：第一次请求时，将导航页传输到客户端，其余请求通过 REST API 获取 JSON 数据
* 实现：数据的传输通过 Web Socket API 或 RPC(远程过程调用)。

* 优点：用户体验流畅，服务器压力小，前后端职责分离
* 缺点：关键词布局难度加大，不利于 SEO

## 什么是“前端路由”? 什么时候适用“前端路由”? 有哪些优点和缺点?

* 前端路由通过 URL 和 History 来实现页面切换
* 应用：前端路由主要适用于“前后端分离”的单页面应用(SPA)项目
* 优点：用户体验好，交互流畅
* 缺点：浏览器“前进”、“后退”会重新请求，无法合理利用缓存

## 如何测试前端代码? 知道 Unit Test，BDD, TDD 么? 怎么测试你的前端工程(mocha, jasmin..)?

* 通过为前端代码编写单元测试(Unit Test)来测试前端代码
* Unit Test：一段用于测试一个模块或接口是否能达到预期结果的代码
* BDD：行为驱动开发 -- 业务需求描述产出产品代码的开发方法
* TDD：测试驱动开发 -- 单元测试用例代码产出产品代码的开发方法
* 单元测试框架：


```javascript
// mocha 示例
describe('Test add', function() {
  it('1 + 2 = 3', function() {
      expect(add(1, 2)).to.be.equal(3);
  });
});

// jasmin 示例
describe('Test add', function () {
    it('1 + 2 = 3', function () {
        expect(add(1, 2)).toEqual(3);
    });
});
```

## E2E

E2E（End To End）即端对端测试，属于黑盒测试，通过编写测试用例，自动化模拟用户操作，确保组件间通信正常，程序流数据传递如预期。

典型E2E测试框架对比

| 名称 | 断言 | 是否跨浏览器支持 | 实现 | 官网 | 是否开源 |
| ---- | ---- | ---- | ---- | ---- |
| nightwatch | assert 和 Chai Expect | 是 | selenium | http://nightwatchjs.org/ | 是 |
| cypress | Chai、Chai-jQuery 等 | 否 | Chrome | https://www.cypress.io/ | 是 |
| testcafe | 自定义的断言 | 是 | 不是基于 selenium 实现 | https://devexpress.github.io/testcafe/ | 是 |
| katalon | TDD/BDD | 是 | 未知 | https://www.katalon.com/katalon-studio/ | 否 |

## 介绍你知道的前端模板引擎？

- artTemplate, underscore, handlebars

## 什么是 Modernizr？ Modernizr 工作原理？

* Modernizr 是一个开源的 JavaScript 库，用于检测用户浏览器对 HTML5 与 CSS3 的支持情况

## 什么是函数式编程？

* 函数式编程是一种"编程范式"，主要思想是把运算过程尽量写成一系列嵌套的函数调用
* 例如：var result = subtract(multiply(add(1,2), 3), 4);

* 函数式编程的特点：
    - 函数核心化：函数可以作为变量的赋值、另一函数的参数、另一函数的返回值
    - 只用“表达式”，不用“语句”：要求每一步都是单纯的运算，都必须有返回值
    - 没有"副作用"：所有功能只为返回一个新的值，不修改外部变量
    - 引用透明：运行不依赖于外部变量，只依赖于输入的参数

* 函数式编程的优点：
    - 代码简洁，接近自然语言，易于理解
    - 便于维护，利于测试、除错、组合
    - 易于“并发编程“，不用担心一个线程的数据，被另一个线程修改
    - 可“热升级”代码，在运行状态下直接升级代码，不需要重启，也不需要停机

## 什么是函数柯里化Currying)？

* 柯里化：
  - 通常也称部分求值，含义是给函数分步传递参数，每次递参部分应用参数，并返回一个更具体的函数，继续接受剩余参数
  - 期间会连续返回具体函数，直至返回最后结果。因此，函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程
  - 柯里化的作用：延迟计算；参数复用；动态创建函数

* 柯里化的缺点：
  - 函数柯里化会产生开销（函数嵌套，比普通函数占更多内存），但性能瓶颈首先来自其它原因（DOM 操作等）

## 什么是依赖注入？

- 当一个类的实例依赖另一个类的实例时，自己不创建该实例，由IOC容器创建并注入给自己，因此称为依赖注入。
- 依赖注入解决的就是如何有效组织代码依赖模块的问题


## 介绍 Yeoman 是什么？

* Yeoman --前端开发脚手架工具，自动将最佳实践和工具整合起来构建项目骨架
* Yeoman 其实是三类工具的合体，三类工具各自独立：
  - yo --- 脚手架，自动生成工具（相当于一个粘合剂，把 Yeoman 工具粘合在一起）
  - Grunt、gulp --- 自动化构建工具 （最初只有grunt，之后加入了gulp）
  - Bower、npm --- 包管理工具 （原来是bower，之后加入了npm）

## 介绍类库和框架的区别？

* 类库是一些函数的集合，帮助开发者写WEB应用，起主导作用的是开发者的代码
* 框架是已实现的特殊WEB应用，开发者只需对它填充具体的业务逻辑，起主导作用是框架


## 说说你对MVC和MVVM的理解
* MVC
  - View 传送指令到 Controller
  - Controller 完成业务逻辑后，要求 Model 改变状态
  - Model 将新的数据发送到 View，用户得到反馈

所有通信都是单向的

## 什么是MVVM？

> MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象

- 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
- ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理

## MVC、MVP 与 MVVM 模式

### 一、MVC

通信方式如下

视图（View）：用户界面。 传送指令到 Controller

控制器（Controller）：业务逻辑 完成业务逻辑后，要求 Model 改变状态

模型（Model）：数据保存 将新的数据发送到 View，用户得到反馈

### 二、MVP

通信方式如下

各部分之间的通信，都是双向的。

View 与 Model 不发生联系，都通过 Presenter 传递。

View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter 非常厚，所有逻辑都部署在那里。

### 三、MVVM

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。通信方式如下

唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。

## 什么是 MVC/MVP/MVVM/Flux？

* MVC(Model-View-Controller)
  - V->C, C->M, M->V
  - 通信都是单向的；C只起路由作用，业务逻辑都部署在V
  - Backbone

* MVP(Model-View-Presenter)
  - V<->P, P<->M
  - 通信都是双向的；V和M不发生联系(通过P传)；V非常薄，逻辑都部署在P
  - Riot.js

* MVVM(Model-View-ViewModel)
  - V->VM, VM<->M
  - 采用双向数据绑定：View 和 ViewModel 的变动都会相互映射到对象上面
  - Angular

* Flux(Dispatcher-Store-View)
  - Action->Dispatcher->Store->View, View->Action
  - Facebook 为了解决在 MVC 应用中碰到的工程性问题提出一个架构思想
  - 基于一个简单的原则：数据在应用中单向流动（单向数据流）
  - React(Flux 中 View，只关注表现层)

## Backbone 是什么？

- Backbone 是一个基于 jquery 和 underscore 的前端(MVC)框架

## AngularJS 是什么？

- AngularJS 是一个完善的前端 MVVM 框架，包含模板、数据双向绑定、路由、模块化、服务、依赖注入等
- AngularJS 由 Google 维护，用来协助大型单一页面应用开发。

## 如何评价AngularJS和BackboneJS

- backbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto)就比一个AngularJS 多出了2 次HTTP请求.

- Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新
- AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令

## Meteor 是什么

- Meteor 是一个全栈开发框架，基础构架是 Node.JS + MongoDB，并把延伸到了浏览器端。
- Meteor 统一了服务器端和客户端的数据访问，使开发者可以轻松完成全栈式开发工作。

## REST

REST就是用URL定位资源，用HTTP描述操作。

URI使用名词而不是动词，且推荐用复数。

BAD
- /getProducts
- /listOrders
- /retrieveClientByOrder?orderId=1

GOOD
- GET /products : will return the list of all products
- POST /products : will add a product to the collection
- GET /products/4 : will retrieve product #4
- PATCH/PUT /products/4 : will update profduct #4


## 是否了解公钥加密和私钥加密？

* 私钥用于对数据进行签名，公钥用于对签名进行验证
* 网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密

## 对称加密和非对称加密

对称加密：

在对称加密算法中，加密和解密使用的是同一把钥匙，即：使用相同的密匙对同一密码进行加密和解密；

优点：算法简单，加密解密容易，效率高，执行快。

缺点：相对来说不算特别安全，只有一把钥匙，密文如果被拦截，且密钥也被劫持，那么，信息很容易被破译。

非对称加密：

在非对称加密算法中，公钥和私钥不是同一把密钥，用户A会将公钥公开，发送给用户B，保留住自己的私钥，用户B发送数据给A时，用A的公钥加密数据，然后发送给A，A收到加密数据后用自己的私钥解密数据。

优点：安全，即使密文被拦截、公钥被获取，但是无法获取到私钥，也就无法破译密文。作为接收方，务必要保管好自己的密钥。

缺点：加密算法及其复杂，安全性依赖算法与密钥，而且加密和解密效率很低。

## 图片相关

**PNG,GIF,JPG的区别及如何选**

- GIF：
  - 8位像素，256色
  - 无损压缩
  - 支持简单动画
  - 支持boolean透明
  - 适合简单动画

- JPEG：
  - 颜色限于256
  - 有损压缩
  - 可控制压缩质量
  - 不支持透明
  - 适合照片

- PNG：
  - 有PNG8和truecolor PNG
  - PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画
  - 适合图标、背景、按钮


## PNG,GIF,JPG 的区别及如何选

参考资料： [选择正确的图片格式](http://www.yuiblog.com/blog/2008/11/04/imageopt-2/)
**GIF**:

1. 8 位像素，256 色
2. 无损压缩
3. 支持简单动画
4. 支持 boolean 透明
5. 适合简单动画

**JPEG**：

1. 颜色限于 256
2. 有损压缩
3. 可控制压缩质量
4. 不支持透明
5. 适合照片

**PNG**：

1. 有 PNG8 和 truecolor PNG
2. PNG8 类似 GIF 颜色上限为 256，文件小，支持 alpha 透明度，无动画
3. 适合图标、背景、按钮

## 如何选择图片格式，例如 png, webp

| 图片格式 | 压缩方式 | 透明度 | 动画 | 浏览器兼容 | 适应场景 |
| ---- | ---- | ---- | ---- | ---- | ---- |

| JPEG | 有损压缩 | 不支持 | 不支持 | 所有 | 复杂颜色及形状、尤其是照片 |
| GIF | 无损压缩 | 支持 | 支持 | 所有 | 简单颜色，动画 |
| PNG | 无损压缩 | 支持 | 不支持 | 所有 | 需要透明时 |
| APNG | 无损压缩 | 支持 | 支持 | Firefox SafariIOS Safari | 需要半透明效果的动画 |
| WebP | 有损压缩 | 支持 | 支持 | Chrome OperaAndroid ChromeAndroid Browser | 复杂颜色及形状浏览器平台可预知 |
| SVG | 无损压缩 | 支持 | 支持 | 所有（IE8以上）||

## 移动端（Android、IOS）怎么做好用户体验?

* 清晰的视觉纵线
* 信息的分组、极致的减法
* 利用选择代替输入
* 标签及文字的排布方式
* 依靠明文确认密码
* 合理的键盘利用

## 前端页面有哪三层构成，分别是什么？作用是什么？

* 结构层：由 (X)HTML 标记语言负责，解决页面“内容是什么”的问题
* 表示层：由 CSS 负责，解决页面“如何显示内容”的问题
* 行为层：由 JS 脚本负责，解决页面上“内容应该如何对事件作出反应”的问题

## 你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？）

* Web App(HTML5)：采用HTML5生存在浏览器中的应用，不需要下载安装
  - 优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端
  - 缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、GPS等）

 * Hybrid App(混合开发)：UI WebView，需要下载安装
   - 优点：接近 Native App 的体验，部分支持离线功能
   - 缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟

* Native App(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用

  - 优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册）
  - 缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核

